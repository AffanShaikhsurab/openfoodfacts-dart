// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'RobotoffQuestion.dart';

// **************************************************************************
// CopyWithGenerator
// **************************************************************************

abstract class _$RobotoffQuestionResultCWProxy {
  RobotoffQuestionResult questions(List<RobotoffQuestion>? questions);

  RobotoffQuestionResult status(String? status);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `RobotoffQuestionResult(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// RobotoffQuestionResult(...).copyWith(id: 12, name: "My name")
  /// ````
  RobotoffQuestionResult call({
    List<RobotoffQuestion>? questions,
    String? status,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfRobotoffQuestionResult.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfRobotoffQuestionResult.copyWith.fieldName(...)`
class _$RobotoffQuestionResultCWProxyImpl
    implements _$RobotoffQuestionResultCWProxy {
  final RobotoffQuestionResult _value;

  const _$RobotoffQuestionResultCWProxyImpl(this._value);

  @override
  RobotoffQuestionResult questions(List<RobotoffQuestion>? questions) =>
      this(questions: questions);

  @override
  RobotoffQuestionResult status(String? status) => this(status: status);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `RobotoffQuestionResult(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// RobotoffQuestionResult(...).copyWith(id: 12, name: "My name")
  /// ````
  RobotoffQuestionResult call({
    Object? questions = const $CopyWithPlaceholder(),
    Object? status = const $CopyWithPlaceholder(),
  }) {
    return RobotoffQuestionResult(
      questions: questions == const $CopyWithPlaceholder()
          ? _value.questions
          // ignore: cast_nullable_to_non_nullable
          : questions as List<RobotoffQuestion>?,
      status: status == const $CopyWithPlaceholder()
          ? _value.status
          // ignore: cast_nullable_to_non_nullable
          : status as String?,
    );
  }
}

extension $RobotoffQuestionResultCopyWith on RobotoffQuestionResult {
  /// Returns a callable class that can be used as follows: `instanceOfRobotoffQuestionResult.copyWith(...)` or like so:`instanceOfRobotoffQuestionResult.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$RobotoffQuestionResultCWProxy get copyWith =>
      _$RobotoffQuestionResultCWProxyImpl(this);
}

abstract class _$RobotoffQuestionCWProxy {
  RobotoffQuestion barcode(String? barcode);

  RobotoffQuestion imageUrl(String? imageUrl);

  RobotoffQuestion insightId(String? insightId);

  RobotoffQuestion insightType(InsightType? insightType);

  RobotoffQuestion question(String? question);

  RobotoffQuestion type(String? type);

  RobotoffQuestion value(String? value);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `RobotoffQuestion(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// RobotoffQuestion(...).copyWith(id: 12, name: "My name")
  /// ````
  RobotoffQuestion call({
    String? barcode,
    String? imageUrl,
    String? insightId,
    InsightType? insightType,
    String? question,
    String? type,
    String? value,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfRobotoffQuestion.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfRobotoffQuestion.copyWith.fieldName(...)`
class _$RobotoffQuestionCWProxyImpl implements _$RobotoffQuestionCWProxy {
  final RobotoffQuestion _value;

  const _$RobotoffQuestionCWProxyImpl(this._value);

  @override
  RobotoffQuestion barcode(String? barcode) => this(barcode: barcode);

  @override
  RobotoffQuestion imageUrl(String? imageUrl) => this(imageUrl: imageUrl);

  @override
  RobotoffQuestion insightId(String? insightId) => this(insightId: insightId);

  @override
  RobotoffQuestion insightType(InsightType? insightType) =>
      this(insightType: insightType);

  @override
  RobotoffQuestion question(String? question) => this(question: question);

  @override
  RobotoffQuestion type(String? type) => this(type: type);

  @override
  RobotoffQuestion value(String? value) => this(value: value);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `RobotoffQuestion(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// RobotoffQuestion(...).copyWith(id: 12, name: "My name")
  /// ````
  RobotoffQuestion call({
    Object? barcode = const $CopyWithPlaceholder(),
    Object? imageUrl = const $CopyWithPlaceholder(),
    Object? insightId = const $CopyWithPlaceholder(),
    Object? insightType = const $CopyWithPlaceholder(),
    Object? question = const $CopyWithPlaceholder(),
    Object? type = const $CopyWithPlaceholder(),
    Object? value = const $CopyWithPlaceholder(),
  }) {
    return RobotoffQuestion(
      barcode: barcode == const $CopyWithPlaceholder()
          ? _value.barcode
          // ignore: cast_nullable_to_non_nullable
          : barcode as String?,
      imageUrl: imageUrl == const $CopyWithPlaceholder()
          ? _value.imageUrl
          // ignore: cast_nullable_to_non_nullable
          : imageUrl as String?,
      insightId: insightId == const $CopyWithPlaceholder()
          ? _value.insightId
          // ignore: cast_nullable_to_non_nullable
          : insightId as String?,
      insightType: insightType == const $CopyWithPlaceholder()
          ? _value.insightType
          // ignore: cast_nullable_to_non_nullable
          : insightType as InsightType?,
      question: question == const $CopyWithPlaceholder()
          ? _value.question
          // ignore: cast_nullable_to_non_nullable
          : question as String?,
      type: type == const $CopyWithPlaceholder()
          ? _value.type
          // ignore: cast_nullable_to_non_nullable
          : type as String?,
      value: value == const $CopyWithPlaceholder()
          ? _value.value
          // ignore: cast_nullable_to_non_nullable
          : value as String?,
    );
  }
}

extension $RobotoffQuestionCopyWith on RobotoffQuestion {
  /// Returns a callable class that can be used as follows: `instanceOfRobotoffQuestion.copyWith(...)` or like so:`instanceOfRobotoffQuestion.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$RobotoffQuestionCWProxy get copyWith => _$RobotoffQuestionCWProxyImpl(this);
}

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

RobotoffQuestionResult _$RobotoffQuestionResultFromJson(
        Map<String, dynamic> json) =>
    RobotoffQuestionResult(
      status: json['status'] as String?,
      questions: (json['questions'] as List<dynamic>?)
          ?.map((e) => RobotoffQuestion.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$RobotoffQuestionResultToJson(
        RobotoffQuestionResult instance) =>
    <String, dynamic>{
      'status': instance.status,
      'questions': instance.questions,
    };

RobotoffQuestion _$RobotoffQuestionFromJson(Map<String, dynamic> json) =>
    RobotoffQuestion(
      barcode: json['barcode'] as String?,
      type: json['type'] as String?,
      value: json['value'] as String?,
      question: json['question'] as String?,
      insightId: json['insight_id'] as String?,
      insightType: $enumDecodeNullable(
          _$InsightTypeEnumMap, json['insight_type'],
          unknownValue: InsightType.UNKNOWN),
      imageUrl: json['source_image_url'] as String?,
    );

Map<String, dynamic> _$RobotoffQuestionToJson(RobotoffQuestion instance) =>
    <String, dynamic>{
      'barcode': instance.barcode,
      'type': instance.type,
      'value': instance.value,
      'question': instance.question,
      'insight_id': instance.insightId,
      'insight_type': _$InsightTypeEnumMap[instance.insightType],
      'source_image_url': instance.imageUrl,
    };

const _$InsightTypeEnumMap = {
  InsightType.INGREDIENT_SPELLCHECK: 'ingredient_spellcheck',
  InsightType.PACKAGER_CODE: 'packager_code',
  InsightType.LABEL: 'label',
  InsightType.CATEGORY: 'category',
  InsightType.PRODUCT_WEIGHT: 'product_weight',
  InsightType.EXPIRATION_DATE: 'expiration_date',
  InsightType.BRAND: 'brand',
  InsightType.STORE: 'store',
  InsightType.NUTRIENT: 'nutrient',
  InsightType.UNDEFINED: 'undefined',
  InsightType.UNKNOWN: 'UNKNOWN',
};
